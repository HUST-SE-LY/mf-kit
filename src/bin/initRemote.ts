import { input, select } from '@inquirer/prompts';
import { copy, ensureDirSync, readFileSync, writeFileSync } from 'fs-extra';
import { join } from 'path';
import {
  localResourceUrl,
  templateBridgeMap,
  templatePathMap,
} from '../constants';
import { MfConfig } from './types';
import { Log } from '../utils/log';

export async function initRemote() {
  const microAppName = await input({ message: 'please enter module name:' });
  let shouldAddToHost: string;
  do {
    shouldAddToHost = await input({
      message: `add ${microAppName} to main app's remote? [y/n]`,
    });
  } while (shouldAddToHost !== 'y' && shouldAddToHost !== 'n');
  const cwd = process.cwd();
  const template = await select({
    message: 'Please select a template',
    choices: [
      {
        name: 'vue3 + webpack',
        value: 'vueWithWebpack',
      },
      {
        name: 'vue3 + rsbuild',
        value: 'vueWithRsbuild',
      },
    ],
  });
  const curMfConfig = JSON.parse(
    readFileSync(join(cwd, `./mf.config.json`), 'utf-8'),
  ) as MfConfig;
  if (curMfConfig.modules[microAppName]) {
    Log.error(`module ${microAppName} has existed!`);
    return;
  }
  const maxPort = Object.values(curMfConfig.modules)
    .filter((el) => localResourceUrl.find((url) => el.startsWith(url)))
    .map((el) => Number(el.split(':').pop()))
    .sort((a, b) => a - b)
    .pop();
  const autoGeneratedPort = (maxPort ? maxPort : curMfConfig.host.port) + 1;
  curMfConfig.modules[microAppName] = `http://127.0.0.1:${autoGeneratedPort}`;
  shouldAddToHost === 'y' &&
    (curMfConfig.host.curRemotes[microAppName] =
      `http://127.0.0.1:${autoGeneratedPort}`);
  const templatePath = join(
    __dirname,
    '../../templates/',
    templatePathMap[template],
  );
  const targetPath = join(cwd, microAppName);
  copy(templatePath, targetPath);
  const packageJson = JSON.parse(
    readFileSync(join(cwd, `./${microAppName}`, '/package.json'), 'utf-8'),
  );
  packageJson.name = microAppName;
  writeFileSync(
    join(cwd, `./${microAppName}`, '/package.json'),
    JSON.stringify(packageJson, null, 2),
  );
  const remoteMfConfig = JSON.parse(
    readFileSync(join(cwd, `./${microAppName}/mf.config.json`), 'utf-8'),
  ) as MfConfig;
  const exportAppTemplatePath = join(
    __dirname,
    '../../templates/',
    remoteMfConfig.template,
  );
  ensureDirSync(join(cwd, `./${microAppName}/mf-exposes`));
  copy(exportAppTemplatePath, join(cwd, `./${microAppName}/mf-exposes`));
  remoteMfConfig.host.exposes['./export-app'] =
    './src/mf-exposes/export-app.ts';
  remoteMfConfig.host.port = autoGeneratedPort;
  if (shouldAddToHost === 'y') {
    const remoteRouterFile = readFileSync(
      join(cwd, './src/router/remoteAppRouter.ts'),
      'utf-8',
    );
    remoteRouterFile.replace(
      `import * as reactBridge from '@module-federation/bridge-react';`,
      `import * as reactBridge from '@module-federation/bridge-react';
const ${microAppName} = ${templateBridgeMap[remoteMfConfig.template]}.createRemoteComponent(() =>
  loadRemote('${microAppName}/export-app'),
);`,
    );
    remoteRouterFile.replace(
      'remoteAppRoutes = [',
      `remoteAppRoutes = [
  {
    path: /${microAppName}/:pathMatch(.*)*,
    component: ${microAppName},
  },`,
    );
  }
}
